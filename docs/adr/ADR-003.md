# ADR-003: Observability, Configuration, and Error Handling Strategy

## Status
Accepted

## Date
2025-XX-XX

## Context

In Stage 3, we turn a contract-first OpenAPI specification into a running FastAPI service.
At this stage, the service must be:

- Observable in production-like environments
- Configurable via environment variables
- Predictable in failure scenarios
- Aligned with HTTP and Problem Details (RFC 7807)

Without explicit decisions, FastAPI applications tend to:
- Log unstructured text
- Mix configuration with code
- Leak internal errors as generic 500s
- Be difficult to debug in containerized or distributed environments

We need a clear, minimal, and production-aligned baseline for:
- Logging
- Configuration
- Health signaling
- Error semantics

## Decision

### 1. Structured Logging

The service uses **structured logging** via `structlog`.

- Logs are emitted as structured key/value events
- Each log entry includes a semantic event name (e.g. `item.get`, `item.create`)
- Contextual data (e.g. `item_id`) is attached as named fields

Example:
```python
logger.info("item.get", item_id=item_id)
```

This enables:

Machine-readable logs

Easy filtering and aggregation in log backends

Clear intent compared to free-form text logs

Logs are written to stdout, which is the standard practice for containerized services.
Log storage and aggregation are delegated to the runtime environment
(e.g. Docker, Kubernetes, or log collectors).

### 2. Health and Readiness Endpoints

We expose two operational endpoints:

- `GET /health`
- `GET /ready`

#### `/health`
Indicates that the process is running.
- Always returns 200 if the app is alive
- No dependency checks

#### `/ready`
Indicates that the service is ready to receive traffic.
- Can fail if critical dependencies are unavailable

This separation prevents traffic from being routed to partially initialized services.

### 3. Error Handling with Problem Details

All application-level errors follow **RFC 7807 – Problem Details for HTTP APIs**.

Error responses:
- Use `application/problem+json`
- Include: `type`, `title`, `status`, `detail`
- Never expose stack traces or internal exceptions

We explicitly distinguish:
- Client errors (4xx): validation, not found, domain constraints
- Server errors (5xx): unexpected or infrastructure failures

An explicit error catalog is maintained (`errors.md`). (From stage 2)

## Consequences

### Positive
- Logs are machine-readable and production-ready
- Configuration is environment-agnostic and testable
- Errors are predictable and contract-aligned
- Service is observable without external tooling
- Clear separation between liveness and readiness

### Trade-offs
- Slight increase in upfront boilerplate
- More explicit error modeling required
- Developers must think in terms of contracts, not exceptions

These trade-offs are intentional and aligned with long-term maintainability.

## Alternatives Considered

### 1. Default FastAPI Logging
Rejected.
- Unstructured
- Hard to correlate across requests

### 2. Inline Configuration in Code
Rejected.
- Breaks environment parity
- Makes containerized deployments fragile

### 3. Returning Raw Exceptions
Rejected.
- Leaks internal details
- Violates API contract and HTTP semantics

## Related Documents (After merging the stage-2 pr)

- ADR-002: Error Model & HTTP Semantics
- `errors.md` – Error Catalog
- `openapi.yaml`
- `RUNBOOK.md`

## References

- RFC 7807: Problem Details for HTTP APIs
- Twelve-Factor App Methodology
- FastAPI Documentation: Dependencies & Middleware
