# ADR-004 — Storage Choices & Indices

**Status:** Accepted  
**Date:** 2026-01-XX  
**Stage:** Stage 4 — Databases (Postgres + MongoDB)

---

## Context

Stage 4 focuses on designing a robust data layer with:

- Clear source of truth
- Optimized read performance
- Measurable index impact
- Safe, reversible migrations

The system models the following domains:

- User
- Item
- Tag

Primary access patterns:

- Transactional writes (create/update/delete)
- Read-heavy queries (lists, filters)
- Tag-based filtering
- Pagination

---

## Decision 1 — Dual Storage Strategy

### Decision

- **Postgres** as the **source of truth**
- **MongoDB** as a **read-optimized projection**

### Rationale

**Postgres**
- ACID-compliant transactions
- Strong referential integrity
- Alembic-managed migrations
- Reliable write consistency

**MongoDB**
- Flexible document schema
- Fast read performance
- Natural support for denormalized documents
- Optimized for read-heavy workloads

### Consequences

- All writes are executed in Postgres first
- MongoDB is updated only after successful commits
- MongoDB is never treated as a source of truth

---

## Decision 2 — Write Model vs Read Model

### Write Model (Postgres)

- Normalized relational schema
- Enforced foreign keys and constraints
- ORM: SQLAlchemy
- Migration tool: Alembic

Tables:
- `users`
- `items`
- `tags`

### Read Model (MongoDB)

- Denormalized documents
- Embedded owner and tag data
- Optimized for list and filter queries

Example document (`items_read`):

```json
{
  "_id": 123,
  "name": "Aged Brie",
  "sell_in": 10,
  "quality": 20,
  "owner": {
    "id": 1,
    "name": "Amir",
    "email": "amir@test.com"
  },
  "tags": ["food", "daily"]
}
```

---

## Decision 3 — Relationship Modeling (Tags)

### Decision

- **One-to-Many relationship**
  - One Item → Many Tags
  - Each Tag belongs to exactly one Item

### Rationale

- Simpler than many-to-many
- Matches current business logic and seed data
- Avoids join/association tables
- Simplifies MongoDB backfill logic

### Consequences

- `tags` table includes `item_id` foreign key
- Cascade delete enabled
- No `item_tags` association table

---

## Decision 4 — Index Strategy (Postgres)

Indexes are derived directly from observed access patterns.

### Users

- Lookup by email
- Enforced uniqueness

```sql
CREATE UNIQUE INDEX ix_users_email ON users(email);
```

---

### Items

- Frequent filtering by owner

```sql
CREATE INDEX ix_items_owner_id ON items(owner_id);
```

---

### Tags

- Tag-based filtering

```sql
CREATE INDEX ix_tags_name ON tags(name);
```

- Join performance with items

```sql
CREATE INDEX ix_tags_item_id ON tags(item_id);
```

---

## Decision 5 — Index Effect Measurement

### Methodology

1. Execute slow query without index
2. Add index
3. Measure performance difference using:
   - Execution time
   - `EXPLAIN ANALYZE`

### Example

**Before index**
```
Seq Scan for owner_id in items table
Execution Time: ~124ms
```

**After index**
```
Index Scan using ix_items_owner
Execution Time: ~054ms
```

Measured results image: `before.png / after.png`.

---

## Decision 6 — Transactions & Consistency

- All Postgres writes are transactional
- MongoDB updates occur only after successful commits
- No distributed transactions
- Eventual consistency is accepted for read models

---

## Decision 7 — Alembic Scope

### Decision

- Alembic manages **Postgres only**
- MongoDB is excluded from migrations

### Rationale

- Alembic is designed for relational schemas
- MongoDB stores derived projections
- Mongo cleanup handled via scripts when required

---

## Decision 8 — Seeding & Backfill

- Seed scripts populate Postgres first
- MongoDB read models are backfilled afterward
- Backfill operations are idempotent
- Mongo `_id` values match Postgres primary keys

---

## Consequences Summary

### Benefits

- Clear separation of concerns
- Optimized read performance
- Safe and reversible migrations
- Measurable performance improvements
- Clean mental model

### Trade-offs

- Data duplication
- Eventual consistency
- Increased architectural complexity

---

## Final Verdict

This architecture fully satisfies Stage 4 requirements:

- Sound relational model
- Read-optimized projection
- Measured index impact
- Reversible migrations
- ≥85% data-layer test coverage
